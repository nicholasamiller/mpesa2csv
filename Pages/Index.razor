@namespace Mpesa2Csv
@page "/"
@using MPesa2Csv.Web.Dialogs
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject IJSRuntime JSRuntime

@using System.Text.RegularExpressions
@using System.Text;
@using iText.IO.Source;
@using iText.Kernel.Exceptions;
@using iText.Kernel.Pdf;
@using iText.Kernel.Pdf.Canvas.Parser;
@using Microsoft.JSInterop;

<PageTitle>Mpesa PDF to CSV converter</PageTitle>

<EditForm  EditContext="editContext" OnValidSubmit="@OnValidSubmit">
    <MudCard>
        <MudCardContent>
            <h1>Convert M-pesa statement PDF to CSV file</h1>
               <InputFile id="fileInput" multiple="false" accept=".pdf" OnChange="UploadFile" hidden/>
            <MudButton HtmlTag="label"
                       Variant="Variant.Filled"
                       Color="Color.Primary"
                       StartIcon="@Icons.Material.Filled.CloudUpload"
                       for="fileInput">
                Upload
            </MudButton>
            @if (model.BrowserFile != null)
            {
                <MudChip Text="@model.BrowserFile.Name" />
            }
               <MudTextField InputType="InputType.Password" Label="Password" HelperText="The password to the PDF file, if any." Class="mt-3" @bind-Value="@model.Password" For="@(() => model.Password)"/>
              
            <ValidationSummary/> 
        </MudCardContent>
        <MudCardActions>
            <MudButton ButtonType="ButtonType.Submit" Variant="Variant.Filled" Color="Color.Primary" Class="ml-auto">
                @if (converting)
                {
                    <MudProgressCircular Indeterminate="true" />
                    <MudText Class="ms-2">Converting...</MudText>
                }
                else
                {
                    <MudText>Convert</MudText>
                }
            </MudButton>                

        </MudCardActions>
    </MudCard>
</EditForm>





@code {
    EditContext editContext;
    FormModel model;
    ValidationMessageStore validationMessageStore;
    bool converting = false;
    PdfDocument cachedPdfDoc;

    protected override void OnInitialized()
    {
        model = new FormModel();
        editContext = new EditContext(model);
        validationMessageStore = new ValidationMessageStore(editContext);
        editContext.OnValidationRequested += HandleValidationRequested;
    }

    private async Task OnValidSubmit()
    {
        converting = true;
        await Run(model.BrowserFile);
        converting = false;
    }

    private async Task UploadFile(InputFileChangeEventArgs e)
    {
        model.BrowserFile = e.File; 
    }

    private void HandleValidationRequested(object? sender, ValidationRequestedEventArgs e)
    {
        // todo: handle file too large issue
        
        validationMessageStore.Clear();
        var password = model.Password;

        var readerProperties = new ReaderProperties().SetPassword(Encoding.UTF8.GetBytes(password));
        try
        {
            var sourceFactory = new RandomAccessSourceFactory();
            var byteSource = sourceFactory.CreateSource(model.BrowserFile.OpenReadStream());
            var pdfReader = new PdfReader(byteSource, readerProperties);
            pdfReader.SetUnethicalReading(true);
            cachedPdfDoc = new PdfDocument(pdfReader);
        }
        catch (BadPasswordException ex)
        {
            validationMessageStore.Add(() => model.Password, "Invalid password");
        }
        catch (Exception ex)
        {
            validationMessageStore.Add(() => model.BrowserFile, "Invalid PDF file."); 
        }
        finally
        {
            model.BrowserFile.OpenReadStream().Dispose();
        }
    }
    
    private async Task Run(IBrowserFile file)
    {
        var csvName = Regex.Replace(file.Name, ".pdf$", ".csv");
        var convertedCsv = await ConvertToCsvAsync(cachedPdfDoc);
        await DownloadCsvAsync(convertedCsv, csvName);
    }

    private async Task<Stream> ConvertToCsvAsync(PdfDocument pdfDoc)
    {
        var resultStream = await Task.Run(() => Converter.ConvertToCsv(pdfDoc));
        return resultStream;
    }

    private async Task DownloadCsvAsync(Stream stream, string csvName)
    {
        using (var outputStream = new MemoryStream())
        {
            await stream.CopyToAsync(outputStream);

            await JSRuntime.InvokeVoidAsync("downloadFromByteArray",
            new
            {
                ByteArray = outputStream.ToArray(),
                FileName = csvName,
                ContentType = "application/pdf"
            });
        }
        stream.Dispose();
    }


    public class FormModel
    {
        public string Password { get; set; }
        public IBrowserFile BrowserFile { get; set; }
    }
}
